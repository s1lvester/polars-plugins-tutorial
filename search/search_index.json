{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How you (yes, you!) can write a Polars Plugin","text":"<ul> <li>\u2705 Unlock super-high performance</li> <li>\u2705 Have a tonne of fun</li> <li>\u2705 Impress everybody with your superpowers</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>Polars is an incredible and groundbreaking Dataframe library, and its expressions API is simply amazing. Sometimes, however, you need to express really custom business logic which just isn't in scope for the Polars API. In that situation, people tend to use <code>map_elements</code>, which lets you express anything but also kills most of Polars' benefits.</p> <p>But it doesn't have to be that way - with just basic Rust knowledge and this tutorial, I postulate that you'll be able to address at least 99% of inefficient <code>map_elements</code> tasks!</p>"},{"location":"#what-will-you-learn","title":"What will you learn","text":"<ul> <li>Writing simple single-column elementwise expressions</li> <li>Writing complex multi-column non-elementwise expressions which use third-party Rust packages</li> <li>How to share your plugin superpowers with others</li> </ul>"},{"location":"#what-are-people-saying","title":"What are people saying?","text":"<p>Nelson Griffiths, Engineering &amp; ML Lead at Double River Investments | Core Maintainer Functime</p> <p>this was an awesome intro. I am no rust expert, though I have written a few plugins. And I learned quite a bit from this! Having my team read it now as well. Thanks for putting this together. I think more content like this for people who don\u2019t know how to write optimal polars code on the rust side will be really useful for people like me who want to work on plugins!</p> <p>Barak David, Software Engineer</p> <p>Amazing tutorial! I just created nltk plugin, and experienced X50 speedup!</p>"},{"location":"abs/","title":"2. How to do ABSolutely nothing","text":"<p>OK, the title's misleading. We won't do \"nothing\", we'll make an <code>abs</code> function which will work on numeric data.</p> <p>We'll do this in phases:</p> <ul> <li><code>abs_i64</code> will take the absolute value of each row of an <code>Int64</code> column</li> <li><code>abs_numeric</code> will take the absolute value of each row in any numeric column</li> </ul>"},{"location":"abs/#abs_i64","title":"<code>abs_i64</code>","text":"<p>Let's start with the Python side - this is almost the same as what we did for <code>noop</code>, we'll just change the names. Please add this to <code>minimal_plugin/__init__.py</code>, right below the definition of <code>noop</code>: <pre><code>def abs_i64(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"abs_i64\",\n        is_elementwise=True,\n    )\n</code></pre></p> <p>Then, please add this to <code>src/expressions.rs</code>, right below the Rust definition of <code>noop</code>:</p> <pre><code>#[polars_expr(output_type=Int64)]\nfn abs_i64(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca: &amp;Int64Chunked = s.i64()?;\n    // NOTE: there's a faster way of implementing `abs_i64`, which we'll\n    // cover in section 7.\n    let out: Int64Chunked = ca.apply(|opt_v: Option&lt;i64&gt;| opt_v.map(|v: i64| v.abs()));\n    Ok(out.into_series())\n}\n</code></pre> <p>The general idea here is:</p> <ul> <li> <p>Each element <code>opt_v</code> can either be <code>Some(i64)</code>, or <code>None</code>.   If it's <code>None</code>, we return <code>None</code>, whereas if it's <code>Some(i64)</code>,   then we return <code>Some</code> of the absolute value of the <code>i64</code> value.</p> <p>Note</p> <p>There's a faster way of implementing <code>abs_i64</code>, which you'll learn about in Branch mispredictions.</p> </li> <li> <p>We produce a new ChunkedArray, convert it to Series, and return it.</p> </li> </ul> <p>Let's try this out. Make a Python file <code>run.py</code> with the following: <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({\n    'a': [1, -1, None],\n    'b': [4.1, 5.2, -6.3],\n    'c': ['hello', 'everybody!', '!']\n})\nprint(df.with_columns(mp.abs_i64('a').name.suffix('_abs')))\n</code></pre> Compile it with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking), and run it with <code>python run.py</code>. If it outputs <pre><code>shape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2506 c          \u2506 a_abs \u2502\n\u2502 ---  \u2506 ---  \u2506 ---        \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str        \u2506 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 4.1  \u2506 hello      \u2506 1     \u2502\n\u2502 -1   \u2506 5.2  \u2506 everybody! \u2506 1     \u2502\n\u2502 null \u2506 -6.3 \u2506 !          \u2506 null  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> then you did everything correctly!</p>"},{"location":"abs/#abs_numeric","title":"<code>abs_numeric</code>","text":"<p>The code above unfortunately only supports <code>Int64</code> columns. Let's try to generalise it a bit, so that it can accept any signed numeric column.</p> <p>First, add the following definition to <code>minimal_plugin/__init__.py</code>:</p> <pre><code>def abs_numeric(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"abs_numeric\",\n        is_elementwise=True,\n    )\n</code></pre> <p>Then, we'll go back to <code>src/expressions.rs</code>. Paste in the following:</p> <pre><code>fn impl_abs_numeric(ca: &amp;Int64Chunked) -&gt; Int64Chunked {\n    // NOTE: there's a faster way of implementing `abs`, which we'll\n    // cover in section 7.\n    ca.apply(|opt_v: Option&lt;i64&gt;| opt_v.map(|v: i64| v.abs()))\n}\n\n#[polars_expr(output_type=Int64)]\nfn abs_numeric(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca: &amp;Int64Chunked = s.i64()?;\n    let out = impl_abs_numeric(ca);\n    Ok(out.into_series())\n}\n</code></pre> <p>Note how it's exactly like <code>abs_i64</code>, but <code>impl_abs_numeric</code> was factored out of the <code>abs_numeric</code> function. It's not yet generic, we need to do a bit more work. The general idea is:</p> <ul> <li>each <code>ChunkedArray</code> is of some Polars Type <code>T</code> (e.g. <code>Int64</code>);</li> <li>to each Polars Type <code>T</code>, there corresponds a Rust native type <code>T::Native</code> (e.g. <code>i64</code>).</li> </ul> <p>Change <code>impl_abs_numeric</code> to:</p> <p><pre><code>fn impl_abs_numeric&lt;T&gt;(ca: &amp;ChunkedArray&lt;T&gt;) -&gt; ChunkedArray&lt;T&gt;\nwhere\n    T: PolarsNumericType,\n    T::Native: Signed,\n{\n    // NOTE: there's a faster way of implementing `abs`, which we'll\n    // cover in section 7.\n    ca.apply(|opt_v: Option&lt;T::Native&gt;| opt_v.map(|v: T::Native| v.abs()))\n}\n</code></pre> Make sure to add <pre><code>use pyo3_polars::export::polars_core::export::num::Signed;\n</code></pre> to the top of the <code>src/expression.rs</code> file.</p> <p>We then need to modify <code>abs_numeric</code> as follows: <pre><code>#[polars_expr(output_type_func=same_output_type)]\nfn abs_numeric(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    match s.dtype() {\n        DataType::Int32 =&gt; Ok(impl_abs_numeric(s.i32().unwrap()).into_series()),\n        DataType::Int64 =&gt; Ok(impl_abs_numeric(s.i64().unwrap()).into_series()),\n        DataType::Float32 =&gt; Ok(impl_abs_numeric(s.f32().unwrap()).into_series()),\n        DataType::Float64 =&gt; Ok(impl_abs_numeric(s.f64().unwrap()).into_series()),\n        dtype =&gt; {\n            polars_bail!(InvalidOperation:format!(\"dtype {dtype} not \\\n            supported for abs_numeric, expected Int32, Int64, Float32, Float64.\"))\n        }\n    }\n}\n</code></pre> That's it! Our function is now generic over signed numeric types, instead of only accepting the <code>Int64</code> type.</p> <p>Finally, modify the <code>print</code> line of <code>run.py</code> to be <pre><code>print(df.with_columns(mp.abs_numeric(pl.col('a', 'b')).name.suffix('_abs')))\n</code></pre></p> <p>Compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking) and then run with <code>python run.py</code>. You should see: <pre><code>shape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2506 c          \u2506 a_abs \u2506 b_abs \u2502\n\u2502 ---  \u2506 ---  \u2506 ---        \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str        \u2506 i64   \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 4.1  \u2506 hello      \u2506 1     \u2506 4.1   \u2502\n\u2502 -1   \u2506 5.2  \u2506 everybody! \u2506 1     \u2506 5.2   \u2502\n\u2502 null \u2506 -6.3 \u2506 !          \u2506 null  \u2506 6.3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Note how we were able to take the absolute value of both <code>b</code> (<code>f64</code>) and <code>a</code> (<code>i64</code>) columns with <code>abs_numeric</code>!</p>"},{"location":"aggregate/","title":"13. In (the) aggregate","text":"<p>Enough transorming columns! Let's aggregate them instead.</p> <p>A Polars expression is a function from a Dataframe to a Series. So, how can we possibly write an expression which produces a scalar?</p> <p>Simple:</p> <ul> <li>write an expression which returns a 1-row Series</li> <li>when you register the expression, pass <code>returns_scalar = True</code></li> </ul> <p>As an example, let's compute the weighted mean of a column, where the weights are given by a second column.</p>"},{"location":"aggregate/#hello-python-my-old-friend","title":"Hello Python my old friend","text":"<p>Nothing fancy here:</p> <pre><code>def vertical_weighted_mean(values: IntoExpr, weights: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[values, weights],\n        lib=lib,\n        symbol=\"vertical_weighted_mean\",\n        is_elementwise=False,\n        returns_scalar=True,\n    )\n</code></pre>"},{"location":"aggregate/#rust","title":"Rust","text":"<p>To keep this example's complexity down, let's just limit it to <code>Float64</code> columns.</p> <pre><code>#[polars_expr(output_type=Float64)]\nfn vertical_weighted_mean(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let values = &amp;inputs[0].f64()?;\n    let weights = &amp;inputs[1].f64()?;\n    let mut numerator = 0.;\n    let mut denominator = 0.;\n    values.iter().zip(weights.iter()).for_each(|(v, w)| {\n        if let (Some(v), Some(w)) = (v, w) {\n            numerator += v * w;\n            denominator += w;\n        }\n    });\n    let result = numerator / denominator;\n    Ok(Series::new(\"\", vec![result]))\n}\n</code></pre>"},{"location":"aggregate/#run-it","title":"Run it!","text":"<p>Put the following in <code>run.py</code>:</p> <pre><code>df = pl.DataFrame({\n    'values': [1., 3, 2, 5, 7],\n    'weights': [.5, .3, .2, .1, .9],\n    'group': ['a', 'a', 'a', 'b', 'b'],\n})\nprint(df.group_by('group').agg(weighted_mean = mp.vertical_weighted_mean('values', 'weights')))\n</code></pre> <p>If you compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if benchmarking), you'll see:</p> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 group \u2506 weighted_mean \u2502\n\u2502 ---   \u2506 ---           \u2502\n\u2502 str   \u2506 f64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 b     \u2506 6.166667      \u2502\n\u2502 a     \u2506 2.333333      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Try omitting <code>returns_scalar=True</code> when registering the expression - what changes?</p>"},{"location":"arguments/","title":"8. I'd like to have an argument, please","text":"<p>Say you want to rewrite <pre><code>def add_suffix(s, *, suffix):\n    return s + suffix\n\ns.map_elements(lambda x: add_suffix(x, suffix='-billy'))\n</code></pre> as a plugin. How can you do that?</p> <p>We've covered passing in extra columns, but...how about passing extra keyword arguments?</p> <p>We'll do this with <code>kwargs</code>. In <code>minimal_plugin/__init__.py</code>, add the following:</p> <pre><code>def add_suffix(expr: IntoExpr, *, suffix: str) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"add_suffix\",\n        is_elementwise=True,\n        kwargs={\"suffix\": suffix},\n    )\n</code></pre> <p>In <code>src/expressions.rs</code>, we'll then first have to define a struct to hold our keyword-arguments:</p> <p><pre><code>#[derive(Deserialize)]\nstruct AddSuffixKwargs {\n    suffix: String,\n}\n</code></pre> Make sure to also add <pre><code>use serde::Deserialize;\n</code></pre> to the top of the file.</p> <p>Then, we can just pass an argument of this type to a <code>add_suffix</code> function, which is going to be very similar to the good version of <code>pig_latinnify</code>:</p> <pre><code>#[polars_expr(output_type=String)]\nfn add_suffix(inputs: &amp;[Series], kwargs: AddSuffixKwargs) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca = s.str()?;\n    let out = ca.apply_to_buffer(|value, output| {\n        write!(output, \"{}{}\", value, kwargs.suffix).unwrap();\n    });\n    Ok(out.into_series())\n}\n</code></pre> <p>To see it in action, compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking), and then you should be able to put <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({'a': ['bob', 'billy']})\nprint(df.with_columns(mp.add_suffix('a', suffix='-billy')))\n</code></pre> into <code>run.py</code>, and run it to get <pre><code>shape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a           \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 bob-billy   \u2502\n\u2502 billy-billy \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> You can add multiple keyword-arguments in the same function, just make sure to include them in the struct which you define on the Rust side.</p>"},{"location":"branch_mispredictions/","title":"7. Branch mispredictions","text":"<p>Time to go back to the past. In Section 2, I told you that the implementation we had of <code>abs_i64</code> wasn't the most efficient one you could possibly write. Time to see how to improve it!</p> <p>Which algorithm do you think would win?</p> <ol> <li>for each row:<ul> <li>check if it's null or not</li> <li>if it's not null, calculate its absolute value</li> </ul> </li> <li>for each row:<ul> <li>calculate its absolute value, even if we don't need it   because it's a null row</li> </ul> </li> </ol> <p>If you've not come across the concept of branch mispredictions before, then the answer may surprise you, because the second one is faster here. This is because <code>.abs</code> is a very fast operation, and wasting time checking whether each element is null or not actually slows us down!</p> <p>Here's how you can make <code>abs_i64</code> faster:</p> <pre><code>#[polars_expr(output_type=Int64)]\nfn abs_i64(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca = s.i64()?;\n    let out = ca.apply_values(|x| x.abs());\n    Ok(out.into_series())\n}\n</code></pre> <p>For operations more complex than <code>.abs</code>, it may be that computing the operation for only the non-null values is cheaper. In general, you should measure, not guess. If you're just starting out with plugins and only need to beat <code>.map_elements</code>, then either of these solutions will blow it out of the water.</p> <p></p>"},{"location":"branch_mispredictions/#practice","title":"Practice!","text":"<p>Can you go back and make a faster version of <code>sum_i64</code>?</p>"},{"location":"cum_sum/","title":"4. Yes we SCAN","text":"<p>The operations we've seen so far have all been elementwise, e.g.:</p> <ul> <li>for each row, we calculated the absolute value</li> <li>for each row, we summed the respective values in two columns</li> </ul> <p>Let's do something (completely) different - instead of working with each row in isolation, we'll calculate a quantity which depends on the rows which precede it.</p> <p>We're going to implement <code>cum_sum</code>.</p>"},{"location":"cum_sum/#python-side","title":"Python side","text":"<p>Add this to <code>minimal_plugin/__init__.py</code>: <pre><code>def cum_sum(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"cum_sum\",\n        is_elementwise=False,\n    )\n</code></pre> Note how, unlike in previous examples, we set <code>is_elementwise=False</code>. You'll see why this is so important at the end of this page.</p>"},{"location":"cum_sum/#rust","title":"Rust","text":"<p>Time to learn a new Rust function: <code>scan</code>. If you're not familiar with it, please take a little break from this tutorial and read the scan docs.</p> <p>Welcome back! Let's use our newfound scan-superpowers to implement <code>cum_sum</code>. Here's what goes into <code>src/expressions.rs</code>: <pre><code>#[polars_expr(output_type_func=same_output_type)]\nfn cum_sum(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca: &amp;Int64Chunked = s.i64()?;\n    let out: Int64Chunked = ca\n        .iter()\n        .scan(0_i64, |state: &amp;mut i64, x: Option&lt;i64&gt;| {\n            match x {\n                Some(x) =&gt; {\n                    *state += x;\n                    Some(Some(*state))\n                },\n                None =&gt; Some(None),\n            }\n        })\n        .collect_trusted();\n    let out: Int64Chunked = out.with_name(ca.name());\n    Ok(out.into_series())\n}\n</code></pre> Make sure to also add <pre><code>use pyo3_polars::export::polars_core::utils::CustomIterTools;\n</code></pre> to the top of the file.</p> <p>The <code>cum_sum</code> definition may look complex, but it's not too bad once we break it down:</p> <ul> <li>we hold the running sum in <code>state</code></li> <li>we iterate over rows, initialising <code>state</code> to be <code>None</code></li> <li>if the current row is <code>Some</code> and <code>state</code> is <code>None</code>,   then set <code>state</code> to the current row's value</li> <li>if the current row is <code>Some</code> and <code>state</code> is <code>Some</code>, then   add the current row's value to <code>state</code></li> <li>if the current row is <code>None</code>, then don't modify <code>state</code>   and emit <code>None</code>.</li> </ul> <p>Note how we use <code>collect_trusted</code> at the end, rather than <code>collect</code>. <code>collect</code> would work as well, but if we know the length of the output (and we do in this case, <code>cum_sum</code> doesn't change the column's length) then we can safely use <code>collect_trusted</code> and save some precious time.</p> <p>Let's compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking), change the last line of <code>run.py</code> to <pre><code>print(df.with_columns(a_cum_sum=mp.cum_sum('a')))\n</code></pre> and then run <code>python run.py</code>:</p> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 a_cum_sum \u2502\n\u2502 --- \u2506 ---  \u2506 ---       \u2502\n\u2502 i64 \u2506 i64  \u2506 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3    \u2506 1         \u2502\n\u2502 5   \u2506 null \u2506 6         \u2502\n\u2502 2   \u2506 -1   \u2506 8         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cum_sum/#elementwise-my-dear-watson","title":"Elementwise, my dear Watson","text":"<p>Why was it so important to set <code>is_elementwise</code> correctly? Let's see with an example.</p> <p>Put the following in <code>run.py</code>: <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({\n    'a': [1, 2, 3, 4, None, 5],\n    'b': [1, 1, 1, 2, 2, 2],\n})\nprint(df.with_columns(a_cum_sum=mp.cum_sum('a')))\n</code></pre></p> <p>Then, run <code>python run.py</code>.</p> <p>Finally, go to <code>minimal_plugin/__init__.py</code> and change <code>is_elementwise</code> from <code>False</code> to <code>True</code>, and run <code>python run.py</code> again.</p> <p>In both cases, you should see the following output: <pre><code>shape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 a_cum_sum \u2502\n\u2502 ---  \u2506 --- \u2506 ---       \u2502\n\u2502 i64  \u2506 i64 \u2506 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1   \u2506 1         \u2502\n\u2502 2    \u2506 1   \u2506 3         \u2502\n\u2502 3    \u2506 1   \u2506 6         \u2502\n\u2502 4    \u2506 2   \u2506 10        \u2502\n\u2502 null \u2506 2   \u2506 null      \u2502\n\u2502 5    \u2506 2   \u2506 15        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> which looks correct. So, what's the deal with <code>is_elementwise</code>?</p> <p>The deal is that we need it in order for window functions / <code>group_by</code>s to be correct. Change the last line of <code>run.py</code> to <pre><code>print(df.with_columns(a_cum_sum=mp.cum_sum('a').over('b')))\n</code></pre></p> <p>Now, we get:</p> <ul> <li> <p>with <code>elementwise=True</code>:</p> <pre><code>shape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 a_cum_sum \u2502\n\u2502 ---  \u2506 --- \u2506 ---       \u2502\n\u2502 i64  \u2506 i64 \u2506 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1   \u2506 1         \u2502\n\u2502 2    \u2506 1   \u2506 3         \u2502\n\u2502 3    \u2506 1   \u2506 6         \u2502\n\u2502 4    \u2506 2   \u2506 10        \u2502\n\u2502 null \u2506 2   \u2506 null      \u2502\n\u2502 5    \u2506 2   \u2506 15        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </li> <li> <p>with <code>elementwise=False</code>:</p> <pre><code>shape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 a_cum_sum \u2502\n\u2502 ---  \u2506 --- \u2506 ---       \u2502\n\u2502 i64  \u2506 i64 \u2506 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1   \u2506 1         \u2502\n\u2502 2    \u2506 1   \u2506 3         \u2502\n\u2502 3    \u2506 1   \u2506 6         \u2502\n\u2502 4    \u2506 2   \u2506 4         \u2502\n\u2502 null \u2506 2   \u2506 null      \u2502\n\u2502 5    \u2506 2   \u2506 9         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> </li> </ul> <p>Only <code>elementwise=False</code> actually respected the window! This is why it's important to set <code>elementwise</code> correctly.</p>"},{"location":"lists/","title":"9.0 Weighted-mean watchers","text":"<p>According to one YouTube talk, the <code>list</code> namespace is one of Polars' main selling points. If you're also a fan of it, this section will teach you how to extend it even further.</p>"},{"location":"lists/#motivation","title":"Motivation","text":"<p>Say you have <pre><code>In [10]: df = pl.DataFrame({\n    ...:     'values': [[1, 3, 2], [5, 7]],\n    ...:     'weights': [[.5, .3, .2], [.1, .9]]\n    ...: })\n\nIn [11]: df\nOut[11]:\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 values    \u2506 weights         \u2502\n\u2502 ---       \u2506 ---             \u2502\n\u2502 list[i64] \u2506 list[f64]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 3, 2] \u2506 [0.5, 0.3, 0.2] \u2502\n\u2502 [5, 7]    \u2506 [0.1, 0.9]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Can you calculate the mean of the values in <code>'values'</code>, weighted by the values in <code>'weights'</code>?</p> <p>So:</p> <ul> <li><code>.5*1 + .3*3 + .2*2 = 1.8</code></li> <li><code>5*.1 + 7*.9 = 6.8</code></li> </ul> <p>I don't know of an easy way to do this with Polars expressions. There probably is a way - but as you'll see here, it's not that hard to write a plugin, and it's probably faster too.</p>"},{"location":"lists/#weighted-mean","title":"Weighted mean","text":"<p>On the Python side, this'll be similar to <code>sum_i64</code>:</p> <pre><code>def weighted_mean(expr: IntoExpr, weights: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr, weights],\n        lib=lib,\n        symbol=\"weighted_mean\",\n        is_elementwise=True,\n    )\n</code></pre> <p>On the Rust side, we'll make use of <code>binary_amortized_elementwise</code>, which you can find in <code>src/utils.rs</code> (if you followed the instructions in Prerequisites). Don't worry about understanding it. Some of its details (such as <code>.as_ref()</code> to get a <code>Series</code> out of an <code>UnstableSeries</code>) are optimizations with some gotchas - unless you really know what you're doing, I'd suggest just using <code>binary_amortized_elementwise</code> directly. Hopefully a utility like this can be added to Polars itself, so that plugin authors won't need to worry about it.</p> <p>To use it, just add <pre><code>use crate::utils::binary_amortized_elementwise;\n</code></pre> to the top of <code>src/expressions.rs</code>, after the previous imports.</p> <p>We just need to write a function which accepts two <code>Series</code>, computes their dot product, and then divides by the sum of the weights:</p> <pre><code>#[polars_expr(output_type=Float64)]\nfn weighted_mean(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let values = inputs[0].list()?;\n    let weights = &amp;inputs[1].list()?;\n\n    let out: Float64Chunked = binary_amortized_elementwise(\n        values,\n        weights,\n        |values_inner: &amp;Series, weights_inner: &amp;Series| -&gt; Option&lt;f64&gt; {\n            let values_inner = values_inner.i64().unwrap();\n            let weights_inner = weights_inner.f64().unwrap();\n            if values_inner.len() == 0 {\n                // Mirror Polars, and return None for empty mean.\n                return None\n            }\n            let mut numerator: f64 = 0.;\n            let mut denominator: f64 = 0.;\n            values_inner\n                .iter()\n                .zip(weights_inner.iter())\n                .for_each(|(v, w)| {\n                    if let (Some(v), Some(w)) = (v, w) {\n                        numerator += v as f64 * w;\n                        denominator += w;\n                    }\n                });\n            Some(numerator / denominator)\n        },\n    );\n    Ok(out.into_series())\n}\n</code></pre> <p>Note: this function has some limitations:</p> <ul> <li>it assumes that each inner element of <code>values</code> and <code>weights</code> has the same   length - it would be better to raise an error if this assumption is not met</li> <li>it only accepts <code>Int64</code> values () (see section 2 for how you could make it more generic).</li> </ul> <p>Nonetheless, if you just need to get a problem solved, it works!</p> <p>To try it out, we compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're  benchmarking), and then we should be able to run <code>run.py</code>:</p> <p><pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({\n    'values': [[1, 3, 2], [5, 7]],\n    'weights': [[.5, .3, .2], [.1, .9]]\n})\nprint(df.with_columns(weighted_mean = mp.weighted_mean('values', 'weights')))\n</code></pre> to see <pre><code>shape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 values    \u2506 weights         \u2506 weighted_mean \u2502\n\u2502 ---       \u2506 ---             \u2506 ---           \u2502\n\u2502 list[i64] \u2506 list[f64]       \u2506 f64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 3, 2] \u2506 [0.5, 0.3, 0.2] \u2506 1.8           \u2502\n\u2502 [5, 7]    \u2506 [0.1, 0.9]      \u2506 6.8           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"lists/#gimme-chocolate-challenge","title":"Gimme chocolate challenge","text":"<p>Could you implement a weighted standard deviation calculator?</p>"},{"location":"lists_in_lists_out/","title":"9.1 Lists in, lists out, lists all about","text":"<p>Chapter 9.0 (Weighted-mean watchers) was fun. Let's do it all over again!</p> <p>Or rather, let's do another list operation. We're going to start with a dataframe such as</p> <p><pre><code>shape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dense        \u2502\n\u2502 ---          \u2502\n\u2502 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [0, 9]       \u2502\n\u2502 [8, 6, 0, 9] \u2502\n\u2502 null         \u2502\n\u2502 [3, 3]       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> and we're going to try to count the indices which are non-zero. \u2192</p> <p>Note</p> <p>You don't really need a plugin to do this, you can just do</p> <pre><code>df.with_columns(sparse_indices=pl.col('dense').list.eval(pl.arg_where(pl.element() != 0)))\n</code></pre> <p>But <code>eval</code> won't cover every need you ever have ever, so...it's good to learn how to do this as a plugin so you can then customize it according to your needs.</p> <p>Polars has a helper function built-in for dealing with this: <code>apply_amortized</code>. We can use it to apply a function to each element of a List Series. In this case, we just want to find the indices of non-zero elements, so we'll do:</p> <p><pre><code>fn list_idx_dtype(input_fields: &amp;[Field]) -&gt; PolarsResult&lt;Field&gt; {\n    let field = Field::new(input_fields[0].name(), DataType::List(Box::new(IDX_DTYPE)));\n    Ok(field.clone())\n}\n\n#[polars_expr(output_type_func=list_idx_dtype)]\nfn non_zero_indices(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let ca = inputs[0].list()?;\n\n    let out: ListChunked = ca.apply_amortized(|s| {\n        let s: &amp;Series = s.as_ref();\n        let ca: &amp;Int64Chunked = s.i64().unwrap();\n        let out: IdxCa = ca\n            .iter()\n            .enumerate()\n            .filter(|(_idx, opt_val)| opt_val != &amp;Some(0))\n            .map(|(idx, _opt_val)| Some(idx as IdxSize))\n            .collect_ca(\"\");\n        out.into_series()\n    });\n    Ok(out.into_series())\n}\n</code></pre> <code>apply_amortized</code> is a bit like the <code>apply_to_buffer</code> function we used in How to STRING something together, in that it makes a big allocation upfront to amortize the allocation costs. Think of it as a list version of <code>apply_values</code>, where each element is itself a <code>Series</code>.</p> <p>Something new in this example is:</p> <ul> <li><code>IdxSize</code></li> <li><code>IdxCa</code></li> <li><code>IDX_DTYPE</code></li> </ul> <p><code>IdxSize</code> is either <code>u32</code> or <code>u64</code>, depending on your platform, and are what Polars generally uses for counting-related operations. <code>IdxCa</code> is the associated <code>ChunkedArray</code>, and <code>IDX_DTYPE</code> the associated Polars dtype.</p> <p>To finish this off, the Python side will be a bog-standard:</p> <pre><code>def non_zero_indices(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr], lib=lib, symbol=\"non_zero_indices\", is_elementwise=True\n    )\n</code></pre> <p>If we then make <code>run.py</code> with</p> <p><pre><code>import polars as pl\nimport minimal_plugin as mp\n\npl.Config().set_fmt_table_cell_list_len(10)\n\ndf = pl.DataFrame({'dense': [[0, 9], [8, 6, 0, 9], None, [3, 3]]})\nprint(df)\nprint(df.with_columns(indices=mp.non_zero_indices('dense')))\n</code></pre> and compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking!) then we'll see</p> <pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dense        \u2506 indices   \u2502\n\u2502 ---          \u2506 ---       \u2502\n\u2502 list[i64]    \u2506 list[u32] \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [0, 9]       \u2506 [1]       \u2502\n\u2502 [8, 6, 0, 9] \u2506 [0, 1, 3] \u2502\n\u2502 null         \u2506 null      \u2502\n\u2502 [3, 3]       \u2506 [0, 1]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Yay, it worked! And not only that, but it's about 1.5x as fast as the <code>list.eval</code> solution noted above!</p>"},{"location":"lost_in_space/","title":"11. Lost in space","text":"<p>Suppose, hypothetically speaking, that you're lost somewhere and only have access to your latitude, your longitude, and a laptop on which you can write a Polars Plugin. How can you find out what the closest city to you is?</p>"},{"location":"lost_in_space/#reverse-geocoding","title":"Reverse geocoding","text":"<p>The practice of starting with a (latitude, longitude) pair and finding out which city it corresponds to is known as reverse geocoding. We're not going to implement a reverse geocoder from scratch - instead, we'll use the <code>reverse-geocoder</code> crate and make a plugin out of it!</p>"},{"location":"lost_in_space/#cargo-here-cargo-there-cargo-everywhere","title":"Cargo here, cargo there, cargo everywhere","text":"<p>Let's add that crate to our project by running <code>cargo add reverse-geocoder</code>. You'll need to activate the nightly Rust channel, which you can do by making a file <code>rust-toolchain.toml</code> in your root directory <pre><code>[toolchain]\nchannel = \"nightly\"\n</code></pre> You'll also need to add <code>polars-arrow</code> and <code>polars-core</code> to <code>Cargo.toml</code> and pin them to the same version that you pin <code>polars</code> to. Yes, this example is getting a bit heavier...</p> <p>The way the <code>reverse-geocoder</code> crate works is:</p> <ul> <li>you instantiate a <code>ReverseGeocoder</code> instance</li> <li>you pass a (latitude, longitude) pair to <code>search</code></li> <li>you get the city name out</li> </ul> <p>So our plugin will work by taking two <code>Float64</code> columns (one of latitude, one for longitude) and producing a String output column.</p>"},{"location":"lost_in_space/#binary-elementwise-apply-to-buffer","title":"Binary elementwise apply to buffer","text":"<p>In How to STRING something together, we learned how to use <code>StringChunked.apply_to_buffer</code> to run an elementwise function on a String column. Does Polars have a binary version of that one which allows us to start from any data type?</p> <p>Unfortunately, not. But, this is a good chance to learn about a few new concepts!</p> <p>We'll start easy by dealing with the Python side. Add the following to <code>minimal_plugin/__init__.py</code>:</p> <pre><code>def reverse_geocode(lat: IntoExpr, long: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[lat, long], lib=lib, symbol=\"reverse_geocode\", is_elementwise=True\n    )\n</code></pre> <p>On the Rust side, in <code>src/expressions.rs</code>, get ready for it, we're going to add:</p> <p><pre><code>use polars_arrow::array::MutablePlString;\nuse polars_core::utils::align_chunks_binary;\nuse reverse_geocoder::ReverseGeocoder;\n\n#[polars_expr(output_type=String)]\nfn reverse_geocode(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let lat = inputs[0].f64()?;\n    let lon = inputs[1].f64()?;\n    let geocoder = ReverseGeocoder::new();\n\n    let (lhs, rhs) = align_chunks_binary(lat, lon);\n    let chunks = lhs\n        .downcast_iter()\n        .zip(rhs.downcast_iter())\n        .map(|(lat_arr, lon_arr)| {\n            let mut mutarr = MutablePlString::with_capacity(lat_arr.len());\n\n            for (lat_opt_val, lon_opt_val) in lat_arr.iter().zip(lon_arr.iter()) {\n                match (lat_opt_val, lon_opt_val) {\n                    (Some(lat_val), Some(lon_val)) =&gt; {\n                        let res = &amp;geocoder.search((*lat_val, *lon_val)).record.name;\n                        mutarr.push(Some(res))\n                    }\n                    _ =&gt; mutarr.push_null(),\n                }\n            }\n\n            mutarr.freeze().boxed()\n        })\n        .collect();\n    let out: StringChunked = unsafe { ChunkedArray::from_chunks(\"placeholder\", chunks) };\n    Ok(out.into_series())\n}\n</code></pre> That's a bit of a mouthful, so let's try to make sense of it.</p> <ul> <li>As we learned about in Prerequisites, Polars Series are backed by chunked arrays.   <code>align_chunks_binary</code> just ensures that the chunks have the same lengths. It may need   to rechunk under the hood for us;</li> <li><code>downcast_iter</code> returns an iterator of Arrow Arrays. Using <code>zip</code>, we iterate over   respective pairs of Arrow Arrays from <code>lhs</code> and <code>rhs</code></li> <li>to learn about <code>MutablePlString</code>, please read   Why we have rewritten our String type</li> </ul> <p>To run it, put the following in <code>run.py</code>: <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({\n    'lat': [37.7749, 51.01, 52.5],\n    'lon': [-122.4194, -3.9, -.91]\n})\nprint(df.with_columns(city=mp.reverse_geocode('lat', 'lon')))\n</code></pre> then compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking) and you should see <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lat     \u2506 lon       \u2506 city              \u2502\n\u2502 ---     \u2506 ---       \u2506 ---               \u2502\n\u2502 f64     \u2506 f64       \u2506 str               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 37.7749 \u2506 -122.4194 \u2506 San Francisco     \u2502\n\u2502 51.01   \u2506 -3.9      \u2506 South Molton      \u2502\n\u2502 52.5    \u2506 -0.91     \u2506 Market Harborough \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> in the output!</p> <p>Great, now in our hypothetical scenario, you're probably still lost, but at least you know which city you're closest to.</p>"},{"location":"noop/","title":"1. How to do nothing","text":"<p>That's right - this section is about how to do nothing.</p> <p>We'll write a Polars plugin which takes an expression, and returns it exactly as it is. Nothing more, nothing less. This will just be an exercise in setting everything up!</p> <p>If you followed the instructions in Prerequisites, then your working directory should look a bit like the following: <pre><code>.\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 minimal_plugin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 expressions.rs\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 utils.rs\n</code></pre></p>"},{"location":"noop/#the-python-side","title":"The Python side","text":"<p>Let's start by getting the Python side ready. It won't run until we implement the Rust side too, but it's a necessary step. Start by adding the following to <code>minimal_plugin/__init__.py</code>:</p> <p><pre><code>def noop(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"noop\",\n        is_elementwise=True,\n    )\n</code></pre> Let's go through this line-by-line:</p> <ul> <li>when we compile Rust, it generates a Shared Object file.   The <code>lib</code> variable holds its filepath;</li> <li>We'll cover <code>is_elementwise</code> in Yes we SCAN, for now don't pay attention to it;</li> <li>We use the utility function <code>register_plugin</code>, provided to us by the cookiecutter.   Polars actually has a public register_plugin_function utility for this, but it was only introduced in   Polars 0.20.16. The <code>register_plugin</code> function we introduce here handles backwards-compatibility   until Polars 0.20.6, so we use that in this tutorial.</li> </ul> <p>Note that string literals are parsed as expressions, so that if somebody calls <code>noop('a')</code>, it gets interpreted as <code>noop(pl.col('a'))</code>.</p>"},{"location":"noop/#lets-get-rusty","title":"Let's get Rusty","text":"<p>Let's leave <code>src/lib.rs</code> as it is, and add the following to <code>src/expressions.rs</code>:</p> <pre><code>fn same_output_type(input_fields: &amp;[Field]) -&gt; PolarsResult&lt;Field&gt; {\n    let field = &amp;input_fields[0];\n    Ok(field.clone())\n}\n\n#[polars_expr(output_type_func=same_output_type)]\nfn noop(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    Ok(s.clone())\n} \n</code></pre> <p>There's a lot to cover here so we'll break it down below.</p>"},{"location":"noop/#defining-noops-schema","title":"Defining <code>noop</code>'s schema","text":"<p>Polars needs to know the schema/dtypes resulting from operations to make good optimization decisions. The way we tell Polars what to expect from our custom function is with the <code>polars_expr</code> attribute.</p> <p>Our beautiful <code>noop</code> doesn't change the data type (in fact, it doesn't change anything...) so we'll just write a function which returns the same input type:</p> <p><pre><code>fn same_output_type(input_fields: &amp;[Field]) -&gt; PolarsResult&lt;Field&gt; {\n    let field = &amp;input_fields[0];\n    Ok(field.clone())\n}\n</code></pre> and use that to define the function output's schema. Just like <code>noop</code>, this function takes a reference to its only input and clones it.</p>"},{"location":"noop/#defining-noops-body","title":"Defining <code>noop</code>'s body","text":"<p>The input is an iterable of <code>Series</code>. In our case, <code>noop</code> just receives a single Series as input, but as we'll see in later sections, it's possible to pass multiple Series.</p> <p>We said we wanted our function to do nothing, so let's implement that: take a reference to the first (and only) input Series, and return a (cheap!) clone of it.</p>"},{"location":"noop/#putting-it-all-together","title":"Putting it all together","text":"<p>Right, does this all work? Let's make a Python file <code>run.py</code> with which to test it out. We'll just make a toy dataframe and apply <code>noop</code> to each column! <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({\n    'a': [1, 1, None],\n    'b': [4.1, 5.2, 6.3],\n    'c': ['hello', 'everybody!', '!']\n})\nprint(df.with_columns(mp.noop(pl.all()).name.suffix('_noop')))\n</code></pre></p> <p>Your working directory should now look a bit like this:</p> <pre><code>.\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 minimal_plugin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 run.py\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 expressions.rs\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 utils.rs\n</code></pre> <p>Let's compile! Please run <code>maturin develop</code> (or <code>maturin develop --release</code> if benchmarking). You'll need to do this every time you change any of your Rust code. It may take a while the first time, but subsequent executions will be significantly faster as the build process is incremental.</p> <p>Finally, you can run your code! If you run <code>python run.py</code> and get the following output: <pre><code>shape: (3, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c          \u2506 a_noop \u2506 b_noop \u2506 c_noop     \u2502\n\u2502 ---  \u2506 --- \u2506 ---        \u2506 ---    \u2506 ---    \u2506 ---        \u2502\n\u2502 i64  \u2506 f64 \u2506 str        \u2506 i64    \u2506 f64    \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 4.1 \u2506 hello      \u2506 1      \u2506 4.1    \u2506 hello      \u2502\n\u2502 1    \u2506 5.2 \u2506 everybody! \u2506 1      \u2506 5.2    \u2506 everybody! \u2502\n\u2502 null \u2506 6.3 \u2506 !          \u2506 null   \u2506 6.3    \u2506 !          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> then it means everything worked correctly. Congrats!</p> <p>You're now ready to learn how to do ABSolutely nothing.</p>"},{"location":"prerequisites/","title":"0. Prerequisites","text":""},{"location":"prerequisites/#knowledge","title":"Knowledge","text":"<p>\"But you know what I like more than materialistic things? Knowledge.\" Tai Lopez</p> <p>How much Rust do you need to know to write your own Polars plugin? Less than you think.</p> <p>I'd suggest starting out with the Rustlings course, which provides some fun and interactive exercises designed to make you familiar with the language. I'd suggest starting the following sections:</p> <ul> <li>00 intro</li> <li>01 variables</li> <li>02 functions</li> <li>03 if</li> <li>05 vecs</li> <li>12 options</li> <li>13 error handling</li> </ul> <p>You'll also need basic Python knowledge: classes, decorators, and functions.</p> <p>Alternatively, you could just clone this repo and then hack away at the examples trial-and-error style until you get what you're looking for - the compiler will probably help you more than you're expecting.</p>"},{"location":"prerequisites/#software","title":"Software","text":"<p>To get started, please install cookiecutter.</p> <p>Then, from your home directory (or wherever you store your Python projects) please run <pre><code>cookiecutter https://github.com/MarcoGorelli/cookiecutter-polars-plugins\n</code></pre> When prompted, please enter (let's suppose your name is \"Maja Anima\", but replace that with your preferred name): <pre><code>[1/3] plugin_name (Polars Cookiecutter): Minimal Plugin\n[2/3] project_slug (polars_minimal_plugin):\n[3/3] author (anonymous): Maja Anima\n</code></pre> This will create a folder call <code>minimal_plugin</code>. Please navigate to it with <code>cd minimal_plugin</code>.</p> <p>Next, create a Python3.8+ virtual environment, and install:</p> <ul> <li><code>polars&gt;=0.20.0</code></li> <li><code>maturin&gt;=1.4.0</code></li> </ul> <p>Finally, you'll also need to install Rust.</p> <p>That's it! However, you are highly encouraged to also install rust-analyzer if you want to improve your Rust-writing experience by exactly 120%.</p>"},{"location":"prerequisites/#whats-in-a-series","title":"What's in a Series?","text":"<p>If you take a look at a Series such as <pre><code>In [9]: s = pl.Series([None, 2, 3]) + 42\n\nIn [10]: s\nOut[10]:\nshape: (3,)\nSeries: '' [i64]\n[\n        null\n        44\n        45\n]\n</code></pre> you may be tempted to conclude that it contains three values: <code>[null, 44, 45]</code>.</p> <p>However, if you print out <code>s._get_buffers()</code>, you'll see something different:</p> <ul> <li><code>s._get_buffers()[\"values\"]</code>: <code>[42, 44, 45]</code>. These are the values.</li> <li><code>s._get_buffers()[\"validity\"]</code>: <code>[False, True, True]</code>. These are the validities.</li> </ul> <p>So we don't really have integers and <code>null</code> mixed together into a single array - we have a pair of arrays, one holding values and another one holding booleans indicating whether each value is valid or not. If a value appears as <code>null</code> to you, then there's no guarantee about what physical number is behind it! It was <code>42</code> here, but it could well be <code>43</code>, or any other number, in another example.</p>"},{"location":"prerequisites/#whats-a-chunk","title":"What's a chunk?","text":"<p>A Series is backed by chunked arrays, each of which holds data which is contiguous in memory.</p> <p>Here's an example of a Series backed  by multiple chunks: <pre><code>In [27]: s = pl.Series([1,2,3])\n\nIn [28]: s = s.append(pl.Series([99, 11]))\n\nIn [29]: s\nOut[29]:\nshape: (5,)\nSeries: '' [i64]\n[\n        1\n        2\n        3\n        99\n        11\n]\n\nIn [30]: s.get_chunks()\nOut[30]:\n[shape: (3,)\n Series: '' [i64]\n [\n        1\n        2\n        3\n ],\n shape: (2,)\n Series: '' [i64]\n [\n        99\n        11\n ]]\n</code></pre> Chunked arrays will come up in several examples in this tutorial.</p>"},{"location":"publishing/","title":"12. Publishing your plugin to PyPI and becoming famous","text":"<p>Here are the steps you should follow:</p> <ol> <li>publish plugin to PyPI</li> <li>???</li> <li>profit</li> </ol> <p>This section deals with step 1, and assumes your project live on GitHub.</p>"},{"location":"publishing/#set-up-trusted-publishing","title":"Set up trusted publishing","text":"<p>If you followed the Prerequisites steps, you should have <code>.github/workflows/publish_to_pypi.yml</code>, <code>Makefile</code>, and <code>requirements.txt</code> files. If not, go back and follow the cookiecutter step.</p> <p>Next, set up an account on Pypi.org, can't do much without that.</p> <p>Third, on PyPI, you'll want to (note: this is taken almost verbatim from PyPA):</p> <ol> <li>Go to https://pypi.org/manage/account/publishing/.</li> <li>Fill in the name you wish to publish your new PyPI project under (the name value in your pyproject.toml), the GitHub repository owner\u2019s name (org or user), and repository name, and the name of the release workflow file under the .github/ folder, see Creating a workflow definition. Finally, add the name of the GitHub Environment (pypi) we\u2019re going set up under your repository. Register the trusted publisher.</li> </ol> <p>Finally, if you make a commit and tag it, and then push, then a release should be triggered! It will then be available for install across different platforms, which would be really hard (impossible?) to do if you were building the wheel manually and uploading to PyPI yourself.</p>"},{"location":"stem/","title":"6. How to CRATE something else entirely","text":"<p>Take a look at crates.io - there's so much good stuff there! There's probably a package for practically any use case.</p> <p>For example, this looks like a fun one: rust_stemmers. It lets us input a word, and stem it (i.e. reduce it to a simpler version, e.g. 'fearlessly' -&gt;  'fearless'). Can we make a plugin out of it?</p>"},{"location":"stem/#cargo-this-cargo-that","title":"Cargo this, cargo that","text":"<p>If we're going to use <code>rust_stemmers</code>, we're going to need to take it on as a dependency. The easiest way to do this is probably to run <code>cargo add rust_stemmers</code> - run this, and watch how <code>Cargo.toml</code> changes! You should see the line <pre><code>rust-stemmers = \"1.2.0\"\n</code></pre> somewhere in there.</p>"},{"location":"stem/#writing-a-snowball-stemmer","title":"Writing a Snowball Stemmer","text":"<p>Let's write a function which:</p> <ul> <li>takes a <code>Utf8</code> columns as input;</li> <li>produces a <code>Utf8</code> column as output.</li> </ul> <p>We'd like to be able to call it as follows:</p> <pre><code>df.with_columns(stemmed_word=mp.snowball_stem('word'))\n</code></pre> <p>On the Python side, let's add the following function to <code>minimal_plugin/__init__.py</code>:</p> <pre><code>def snowball_stem(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"snowball_stem\",\n        is_elementwise=True,\n    )\n</code></pre> <p>Then, we can define the function like this in <code>src/expressions.rs</code>:</p> <pre><code>use rust_stemmers::{Algorithm, Stemmer};\n\n#[polars_expr(output_type=String)]\nfn snowball_stem(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let ca: &amp;StringChunked = inputs[0].str()?;\n    let en_stemmer = Stemmer::create(Algorithm::English);\n    let out: StringChunked = ca.apply_to_buffer(|value: &amp;str, output: &amp;mut String| {\n        write!(output, \"{}\", en_stemmer.stem(value)).unwrap()\n    });\n    Ok(out.into_series())\n}\n</code></pre> <p>Let's try it out! Put the following in <code>run.py</code>: <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({'word': [\"fearlessly\", \"littleness\", \"lovingly\", \"devoted\"]})\nprint(df.with_columns(b=mp.snowball_stem('word')))\n</code></pre></p> <p>If you then compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking), and run it with <code>python run.py</code>, you'll see: <pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a          \u2506 b        \u2502\n\u2502 ---        \u2506 ---      \u2502\n\u2502 str        \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 fearlessly \u2506 fearless \u2502\n\u2502 littleness \u2506 littl    \u2502\n\u2502 lovingly   \u2506 love     \u2502\n\u2502 devoted    \u2506 devot    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>In this example, we took on an extra dependency, which increased the size of the package. By using plugins, we have a way of accessing extra functionality without having to bloat up the size of the main Polars install too much!</p>"},{"location":"stem/#stretch-goal","title":"Stretch goal","text":"<p>Browse through <code>crates.io</code> - is there any other crate you could use to make your own plugin out of?</p>"},{"location":"stringify/","title":"5. How to STRING something together","text":"<p>Tired of examples which only include numeric data? Me neither. But we need to address the elephant in the room: strings.</p> <p>We're going to start by re-implementing a pig-latinnifier. This example is already part of the <code>pyo3-polars</code> repo examples, but we'll tackle it with a different spin here by first doing it the wrong way \ud83d\ude08.</p>"},{"location":"stringify/#pig-latinnify-take-1","title":"Pig-latinnify - take 1","text":"<p>Let's start by doing this the wrong way. We'll use our <code>abs</code> example, and adapt it to the string case. We'll follow the same strategy:</p> <ul> <li>iterate over arrow arrays;</li> <li>for each element in each array, create a new output value.</li> </ul> <p>Put the following in <code>src/expressions.rs</code>:</p> <p><pre><code>use std::borrow::Cow;\nuse std::fmt::Write;\n\n#[polars_expr(output_type=String)]\nfn pig_latinnify(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let s = &amp;inputs[0];\n    let ca = s.str()?;\n    let out: StringChunked = ca.apply(|opt_v: Option&lt;&amp;str&gt;| {\n        opt_v.map(|value: &amp;str| {\n            // Not the recommended way to do it,\n            // see below for a better way!\n            if let Some(first_char) = value.chars().next() {\n                Cow::Owned(format!(\"{}{}ay\", &amp;value[1..], first_char))\n            } else {\n                Cow::Borrowed(value)\n            }\n        })\n    });\n    Ok(out.into_series())\n}\n</code></pre> If you're not familiar with clone-on-write, don't worry about it - we're about to see a simpler and better way to do this anyway. What I'd like you to focus on is that for every row, we're creating a new <code>String</code>.</p> <p>If you combine this with a Python definition (which you should put in <code>minimal_plugin/__init__.py</code>):</p> <p><pre><code>def pig_latinnify(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"pig_latinnify\",\n        is_elementwise=True,\n    )\n</code></pre> then you'll be able to pig-latinnify a column of strings! To see it in action, compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking) and put the following in <code>run.py</code>:</p> <p><pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({'a': [\"I\", \"love\", \"pig\", \"latin\"]})\nprint(df.with_columns(a_pig_latin=mp.pig_latinnify('a')))\n</code></pre> <pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 a_pig_latin \u2502\n\u2502 ---   \u2506 ---         \u2502\n\u2502 str   \u2506 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 I     \u2506 Iay         \u2502\n\u2502 love  \u2506 ovelay      \u2502\n\u2502 pig   \u2506 igpay       \u2502\n\u2502 latin \u2506 atinlay     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>This will already be an order of magnitude faster than using <code>map_elements</code>. But as mentioned earlier, we're creating a new string for every single row.</p> <p>Can we do better?</p>"},{"location":"stringify/#pig-latinnify-take-2","title":"Pig-latinnify - take 2","text":"<p>Yes! <code>StringChunked</code> has a utility <code>apply_to_buffer</code> method which amortises the cost of creating new strings for each row by creating a string upfront, clearing it, and repeatedly writing to it. This gives a 4x speedup! All you need to do is change <code>pig_latinnify</code> to:</p> <pre><code>#[polars_expr(output_type=String)]\nfn pig_latinnify(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let ca: &amp;StringChunked = inputs[0].str()?;\n    let out: StringChunked = ca.apply_to_buffer(|value: &amp;str, output: &amp;mut String| {\n        if let Some(first_char) = value.chars().next() {\n            write!(output, \"{}{}ay\", &amp;value[1..], first_char).unwrap()\n        }\n    });\n    Ok(out.into_series())\n}\n</code></pre> <p>Simpler, faster, and more memory-efficient. Thinking about allocations can really make a difference!</p>"},{"location":"struct/","title":"10. STRUCTin'","text":"<p>\"Day one, I'm in love with your struct\" Thumpasaurus (kinda)</p> <p>How do we consume structs, and how do we return them?</p> <p>To learn about structs, we'll rewrite a plugin which takes a <code>Struct</code> as input, and shifts all values forwards by one key. So, for example, if the input was <code>{'a': 1, 'b': 2., 'c': '3'}</code>, then the output will be <code>{'a': 2., 'b': '3', 'c': 1}</code>.</p> <p>On the Python side, usual business:</p> <pre><code>def shift_struct(expr: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr],\n        lib=lib,\n        symbol=\"shift_struct\",\n        is_elementwise=True,\n    )\n</code></pre> <p>On the Rust side, we need to start by activating the necessary feature - in <code>Cargo.toml</code>, please make this change: <pre><code>-polars = { version = \"0.41.3\", default-features = false }\n+polars = { version = \"0.41.3\", features=[\"dtype-struct\"], default-features = false }\n</code></pre></p> <p>Then, we need to get the schema right. <pre><code>fn shifted_struct(input_fields: &amp;[Field]) -&gt; PolarsResult&lt;Field&gt; {\n    let field = &amp;input_fields[0];\n    match field.data_type() {\n        DataType::Struct(fields) =&gt; {\n            let mut field_0 = fields[0].clone();\n            let name = field_0.name().clone();\n            field_0.set_name(fields[fields.len() - 1].name().clone());\n            let mut fields = fields[1..]\n                .iter()\n                .zip(fields[0..fields.len() - 1].iter())\n                .map(|(fld, name)| Field::new(name.name(), fld.data_type().clone()))\n                .collect::&lt;Vec&lt;_&gt;&gt;();\n            fields.push(field_0);\n            Ok(Field::new(&amp;name, DataType::Struct(fields)))\n        }\n        _ =&gt; unreachable!(),\n    }\n}\n</code></pre> In this case, I put the first field's name as the output struct's name, but it doesn't really matter what we put, as Polars doesn't allow us to rename expressions within plugins. You can always rename on the Python side if you really want to, but I'd suggest to just let Polars follow its usual \"left-hand-rule\".</p> <p>The function definition is going to follow a similar logic:</p> <pre><code>#[polars_expr(output_type_func=shifted_struct)]\nfn shift_struct(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let struct_ = inputs[0].struct_()?;\n    let fields = struct_.fields();\n    if fields.is_empty() {\n        return Ok(inputs[0].clone());\n    }\n    let mut field_0 = fields[0].clone();\n    field_0.rename(fields[fields.len() - 1].name());\n    let mut fields = fields[1..]\n        .iter()\n        .zip(fields[..fields.len() - 1].iter())\n        .map(|(s, name)| {\n            let mut s = s.clone();\n            s.rename(name.name());\n            s\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n    fields.push(field_0);\n    StructChunked::new(struct_.name(), &amp;fields).map(|ca| ca.into_series())\n}\n</code></pre> <p>Let's try this out. Put the following in <code>run.py</code>:</p> <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame(\n    {\n        \"a\": [1, 3, 8],\n        \"b\": [2.0, 3.1, 2.5],\n        \"c\": [\"3\", \"7\", \"3\"],\n    }\n).select(abc=pl.struct(\"a\", \"b\", \"c\"))\nprint(df.with_columns(abc_shifted=mp.shift_struct(\"abc\")))\n</code></pre> <p>Compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking), and if you run <code>python run.py</code> you'll see:</p> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 abc         \u2506 abc_shifted \u2502\n\u2502 ---         \u2506 ---         \u2502\n\u2502 struct[3]   \u2506 struct[3]   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 {1,2.0,\"3\"} \u2506 {2.0,\"3\",1} \u2502\n\u2502 {3,3.1,\"7\"} \u2506 {3.1,\"7\",3} \u2502\n\u2502 {8,2.5,\"3\"} \u2506 {2.5,\"3\",8} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The values look right - but is the schema? Let's take a look <pre><code>import pprint\npprint.pprint(df.with_columns(abc_shifted=mp.shift_struct(\"abc\")).schema)\n</code></pre> <pre><code>OrderedDict([('abc', Struct({'a': Int64, 'b': Float64, 'c': String})),\n             ('abc_shifted', Struct({'a': Float64, 'b': String, 'c': Int64}))])\n</code></pre> Looks correct!</p>"},{"location":"sum/","title":"3. How to do SUMthing","text":"<p>So far, the expressions we wrote only operated on a single expression.</p> <p>What if we'd like to do something fancier, involving more than one expression? Let's try to write an expression which lets us do</p> <pre><code>df.with_columns(mp.sum_i64('a', 'b'))\n</code></pre>"},{"location":"sum/#take-a-ride-on-the-python-side","title":"Take a ride on the Python side","text":"<p>First, we need to be able to pass multiple inputs to our Rust function. We'll do that by using the <code>args</code> argument when we register our expression. Add the following to <code>minimal_plugins/__init__.py</code>:</p> <pre><code>def sum_i64(expr: IntoExpr, other: IntoExpr) -&gt; pl.Expr:\n    return register_plugin(\n        args=[expr, other],\n        lib=lib,\n        symbol=\"sum_i64\",\n        is_elementwise=True,\n    )\n</code></pre>"},{"location":"sum/#ive-got-1100011-problems-but-binary-aint-one","title":"I\u2019ve got 1100011 problems but binary ain't one","text":"<p>Time to write a binary function, in the sense that it takes two columns as input and produces a third. Polars gives us a handy <code>binary_elementwise</code> function for computing binary elementwise operations called <code>binary_elementwise</code>.</p> <p>Add the following to <code>src/expressions.rs</code>:</p> <p><pre><code>#[polars_expr(output_type=Int64)]\nfn sum_i64(inputs: &amp;[Series]) -&gt; PolarsResult&lt;Series&gt; {\n    let left: &amp;Int64Chunked = inputs[0].i64()?;\n    let right: &amp;Int64Chunked = inputs[1].i64()?;\n    // Note: there's a faster way of summing two columns, see\n    // section 7.\n    let out: Int64Chunked = binary_elementwise(\n        left,\n        right,\n        |left: Option&lt;i64&gt;, right: Option&lt;i64&gt;| match (left, right) {\n            (Some(left), Some(right)) =&gt; Some(left + right),\n            _ =&gt; None,\n        },\n    );\n    Ok(out.into_series())\n}\n</code></pre> Note that you'll also need to add <pre><code>use polars::prelude::arity::binary_elementwise;\n</code></pre> to the top of the <code>src/expressions.rs</code> file.</p> <p>Note</p> <p>There's a faster way of implementing this particular operation, which we'll cover later in the tutorial in Branch mispredictions.</p> <p>The idea is:</p> <ul> <li>for each row, if both <code>left</code> and <code>right</code> are valid (i.e. they are both   <code>Some</code>), then we sum them;</li> <li>if either of them is missing (<code>None</code>), then we return <code>None</code>.</li> </ul> <p>To try it out, remember to first compile with <code>maturin develop</code> (or <code>maturin develop --release</code> if you're benchmarking). Then if you make a <code>run.py</code> file with <pre><code>import polars as pl\nimport minimal_plugin as mp\n\ndf = pl.DataFrame({'a': [1, 5, 2], 'b': [3, None, -1]})\nprint(df.with_columns(a_plus_b=mp.sum_i64('a', 'b')))\n</code></pre> then <code>python run.py</code> should produce <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 a_plus_b \u2502\n\u2502 --- \u2506 ---  \u2506 ---      \u2502\n\u2502 i64 \u2506 i64  \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3    \u2506 4        \u2502\n\u2502 5   \u2506 null \u2506 null     \u2502\n\u2502 2   \u2506 -1   \u2506 1        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"sum/#get-over-your-exercises","title":"Get over your exercises","text":"<p>It's widely acknowledged that the best way to learn is by doing.</p> <p>Can you make <code>sum_numeric</code> (a generic version of <code>sum_i64</code>)? Can you support the case when <code>left</code> and <code>right</code> are of different types, e.g. <code>i8</code> plus <code>i16</code>?</p>"},{"location":"where_to_go/","title":"Where to go from here?","text":"<p>What now?</p> <p>If this material was a bit overwhelming for you, I'd suggest taking a step back and reading The Rust Programming Language. Or at least, the first 10 chapters.</p> <p>Next, you may be interested in looking at existing plugins for inspiration. There's a nice list of them in the official user guide: https://docs.pola.rs/user-guide/expressions/plugins/.</p> <p>Finally, you should definitely join the Discord Server, where there's a channel dedicated to plugins: https://discord.gg/4UfP5cfBE7.</p>"}]}